#!/usr/bin/env python3

import argparse
import json
import os
import re

def write_c_header_file(file, apis, public_header=False):
  if not public_header:
    file.write('// This file is automatically generated by write_c_impls.py\n\n'
               '#if defined(CHROHIME_C_IMPLEMENTATION)\n')
    for api in apis:
      if api['type'] in [ 'refcounted', 'class', 'enum' ]:
        if is_content_api(api):
          file.write('#if defined(CHROHIME_WITH_CONTENT)\n')
        file.write(f'using hime::{api["name"]};\n')
        if is_content_api(api):
          file.write('#endif\n')
    # Write the typedefs for actual C++ implementations.
    for api in apis:
      if api['type'] in [ 'refcounted', 'class' ]:
        if is_content_api(api):
          file.write('#if defined(CHROHIME_WITH_CONTENT)\n')
        file.write(f'typedef {api["name"]}* {get_c_type_name(api)};\n')
        if is_content_api(api):
          file.write('#endif\n')
    file.write('#else\n')
  # Write fake typedefs for library users.
  file.write('// Declarations for opaque pointers.\n')
  for api in apis:
    if api['type'] in [ 'refcounted', 'class' ]:
      api_name = get_c_name(api)
      file.write(f'typedef struct hime_{api_name}_tag* {get_c_type_name(api)};\n')
  if not public_header:
    file.write('#endif\n')
  file.write('\n')
  for api in apis:
    if api['type'] in [ 'enum', 'enum class' ]:
      file.write(get_enum_declaration(api, public_header=public_header))
  file.write('#if defined(__cplusplus)\n'
             'extern "C" {\n'
             '#endif\n\n')
  for api in apis:
    write_c_impls(file, apis, api, write_impl=False, public_header=public_header)
  file.write('#if defined(__cplusplus)\n'
             '}\n'
             '#endif\n')

def write_c_impl_file(file, apis):
  file.write('// This file is automatically generated by write_c_impls.py\n\n')
  # Write converters between structures.
  file.write('namespace {\n\n')
  for api in apis:
    if api['type'] in [ 'struct', 'geometry', 'enum', 'enum class' ]:
      write_converters(file, api)
  # Write a helper for converting c struct array to vectors.
  file.write('template<typename T, typename F>\n'
             'std::vector<T> ToHimeVector(F* from, size_t from_size) {\n'
             '  std::vector<T> result;\n'
             '  result.reserve(from_size);\n'
             '  for (size_t i = 0; i < from_size; ++i)\n'
             '    result.push_back(ToHime(from + i));\n'
             '  return result;\n'
             '}\n\n')
  file.write('}  // namespace\n\n')
  # Write the implementations of APIs.
  for api in apis:
    write_c_impls(file, apis, api, write_impl=True)

def write_converters(file, api):
  api_type_name = get_c_type_name(api)
  api_cpp_type = api['name']
  if api['type'] == 'struct':
    set_properties = [ 'cpp.{0} = c->{0};\n'.format(get_c_name(prop)) for prop in api['properties'] ]
    write_function(file, api, True,
                   f'{api_cpp_type} ToHime',
                   [ f'{api_type_name}* c' ],
                   f'if (c->struct_size != sizeof({api_type_name})) {{\n'
                   f'  assert(false);\n'
                   f'}}\n'
                   f'{api_cpp_type} cpp;\n' + ''.join(set_properties) + \
                   f'return cpp;')
  elif api['type'] == 'geometry':
    # Write a converter from c to cpp.
    args = [ f'c.{get_c_name(prop)}' for prop in api['properties'] ]
    write_function(file, api, True,
                   f'inline {api_cpp_type} ToHime',
                   [ f'{api_type_name} c' ],
                   f'return {api_cpp_type}({params_join(args)});')
    # Write a converter from c to absl::optional.
    write_function(file, api, True,
                   f'inline absl::optional<{api_cpp_type}> ToHime',
                   [ f'{api_type_name}* ptr' ],
                   f'if (!ptr)\n'
                   f'  return absl::optional<{api_cpp_type}>();\n'
                   f'return ToHime(*ptr);')
    # Write a converter from cpp to c.
    set_properties = [ 'c.{0} = cpp.{0}();\n'.format(get_c_name(prop)) for prop in api['properties'] ]
    write_function(file, api, True,
                   f'inline {api_type_name} FromHime',
                   [ f'const {api_cpp_type}& cpp' ],
                   f'{api_type_name} c;\n' + ''.join(set_properties) + \
                   f'return c;')
  elif api['type'] in [ 'enum', 'enum class' ]:
    def get_cpp_enum_name(api, enum):
      cpp_enum = enum['name']
      if api['type'] == 'enum class':
        cpp_enum = api['name'] + '::k' + cpp_enum
      elif api['name'] == 'ColorId':
        cpp_enum = 'ui::kColor' + cpp_enum
      elif api['name'] == 'enum':
        cpp_enum = 'k' + api['name'] + cpp_enum
      return cpp_enum
    # Write a converter from c to cpp.
    return_enum_classes = [
        f'  case {get_enum_name(api, enum)}:\n'
        f'    return {get_cpp_enum_name(api, enum)};\n' for enum in api['enums'] ]
    write_function(file, api, True,
                   f'inline {api_cpp_type} ToHime',
                   [ f'{api_type_name} c' ],
                   f'switch (c) {{\n' + ''.join(return_enum_classes) + \
                   f'}}\n')
    # Write a converter from cpp to c.
    return_enums = [
        f'  case {get_cpp_enum_name(api, enum)}:\n'
        f'    return {get_enum_name(api, enum)};\n' for enum in api['enums'] ]
    write_function(file, api, True,
                   f'inline {api_type_name} FromHime',
                   [ f'{api_cpp_type} cpp' ],
                   'switch (cpp) {\n' + ''.join(return_enums) + \
                   f'  default: return static_cast<{api_type_name}>(0);\n'
                   '}\n')

def write_c_impls(file, apis, api, write_impl, public_header=False):
  if api['type'] in [ 'struct', 'geometry' ]:
    write_struct_impl(file, apis, api, write_impl, public_header)
  elif api['type'] in [ 'refcounted', 'class' ]:
    if is_content_api(api):
      file.write('#if defined(CHROHIME_WITH_CONTENT)\n\n')
    write_class_impl(file, apis, api, write_impl, public_header)
    if is_content_api(api):
      file.write('#endif  // defined(CHROHIME_WITH_CONTENT)\n\n')

def write_struct_impl(file, apis, api, write_impl, public_header):
  if write_impl:
    return
  api_name = get_c_name(api)
  api_type_name = get_c_type_name(api)
  if public_header:
    file.write(get_comment(api))
  # Write the struct declaration.
  file.write(f'typedef struct {{\n')
  if api['type'] == 'struct':
    file.write(f'  uint32_t struct_size;\n')
  for prop in api['properties']:
    prop_type = get_c_parameter_type(apis, prop['type'])
    prop_name = get_c_name(prop)
    file.write(f'  {prop_type} {prop_name};\n')
  file.write(f'}} {api_type_name};\n')
  # A define that sets the size member and init default values.
  set_properties = []
  if api['type'] == 'struct':
    set_properties.append(f'({api_name})->struct_size = sizeof({api_type_name})')
  for prop in api['properties']:
    prop_name = get_c_name(prop)
    default_value = get_c_value(prop['defaultValue'])
    set_properties.append(f'({api_name})->{prop_name} = {default_value}')
  file.write(f'#define hime_{api_name}_init({api_name}) \\\n')
  file.write(prefix_each_line('; \\\n'.join(set_properties), '  '))
  file.write('\n')

def write_class_impl(file, apis, api, write_impl, public_header):
  api_name = get_c_name(api)
  api_prefix = f'hime_{api_name}'
  api_type_name = f'{api_prefix}_t'
  # Write class_create constructor methods.
  for constructor in api['constructors']:
    if public_header:
      file.write(get_comment(constructor))
    constructor_args = params_join(get_c_args(apis, api, constructor))
    constructor_call = f'new {api["name"]}({constructor_args})'
    if api['type'] == 'refcounted':
      # The refcounted types require putting into scoped_refptr first.
      constructor_call = f'base::AdoptRef({constructor_call}).release()'
    write_function(file, constructor, write_impl,
                   f'{api_type_name} {api_prefix}_{get_c_name(constructor)}',
                   get_c_params(apis, api, constructor),
                   f'return {constructor_call};')
  # Write class_destroy methods.
  if api['type'] == 'class':
    write_function(file, {}, write_impl,
                   f'void {api_prefix}_destroy',
                   [ f'{api_type_name} {api_name}' ],
                   f'delete {api_name};')
  # Write class methods.
  for method in api['class_methods']:
    if public_header:
      file.write(get_comment(method))
    return_type = get_c_return_type(apis, method['returnType'])
    write_function(file, method, write_impl,
                   f'{return_type} {api_prefix}_{get_c_name(method)}',
                   get_c_params(apis, api, method),
                   f'return {api["name"]}::{get_function_call(apis, api, method)};')
  # Write normal methods.
  for method in api['methods']:
    if public_header:
      file.write(get_comment(method))
    return_type = get_c_return_type(apis, method['returnType'])
    method_name = get_c_name(method)
    params = get_c_params(apis, api, method, include_this=True)
    if method['returnType'] == 'std::u16string':
      write_function(file, method, write_impl,
                     f'size_t {api_prefix}_{method_name}_size',
                     params,
                     f'return {get_function_call(apis, api, method, include_this=True)}.size();')
      write_function(file, method, write_impl,
                     f'{return_type} {api_prefix}_{method_name}',
                     params + [ 'char16_t* out', 'size_t size' ],
                     f'{method["returnType"]} result = {get_function_call(apis, api, method, include_this=True)};\n'
                     f'std::copy_n(result.begin(), std::min(result.size(), size), out);')
    else:
      write_function(file, method, write_impl,
                     f'{return_type} {api_prefix}_{method_name}',
                     params,
                     get_method_impl(apis, api, method))
  # Write events.
  for event in api['events']:
    if public_header:
      file.write(get_comment(event))
    event_name = get_c_name(event)
    event_api_prefix = f'{api_prefix}_{event_name}'
    event_callback_type = f'{event_api_prefix}_callback'
    if not write_impl:
      # Write definition of callback type.
      event_parameters = get_c_params(apis, api, event) + [ 'void* data' ]
      file.write(f'typedef {event["returnType"]} (*{event_callback_type})(\n'
                 f'    {params_join(event_parameters)});\n\n')
    callback_params = [
        f'{event_callback_type} callback',
        f'void* data',
        f'hime_free_callback free' ] + get_c_params(apis, api, event)
    callback_args = get_c_args(apis, api, event) + [ 'data' ]
    write_function(file, event, write_impl,
                   f'int32_t {event_api_prefix}_connect_closure',
                   [ f'{api_type_name} {api_name}',
                     f'{event_callback_type} callback',
                     'void* data',
                     'hime_free_callback free' ],
                   f'return {api_name}->{event_name}.Connect(base::BindRepeating(\n'
                   f'    []({params_join(callback_params)}) {{\n'
                   f'        callback({params_join(callback_args)});\n'
                   f'        if (free)\n'
                   f'          free(data);\n'
                   f'    }}, callback, data, free));\n')
    if not write_impl:
      # Write a event_connect define for simplifying API.
      file.write(f'#define {event_api_prefix}_connect({api_name}, callback, data) \\\n'
                 f'  {event_api_prefix}_connect_closure({api_name}, callback, data, NULL)\n\n')
    write_function(file, event, write_impl,
                   f'void {event_api_prefix}_disconnect',
                   [ f'{api_type_name} {api_name}',
                     'uint32_t signal_id' ],
                   f'{api_name}->{event_name}.Disconnect(signal_id);');

def write_function(file, data, write_impl, name, params, impl, export=True):
  defines = get_platform_defines(data)
  if len(defines) > 0:
    defined = ' || '.join([f'defined({define})' for define in  defines])
    file.write(f'#if {defined}\n')
  if export and not write_impl:
    file.write('CHROHIME_C_EXPORT\n')
  file.write(f'{name}({params_join(params)})')
  if write_impl:
    file.write(' {\n' + prefix_each_line(impl, '  ') + '}\n')
  else:
    file.write(';\n')
  if len(defines) > 0:
    file.write('#endif\n')
  file.write('\n')

def is_content_api(api):
  return 'content' in api and api['content']

def get_comment(data):
  if not 'description' in data:
    return ''
  lines = data['description'].splitlines()
  comments = ['// ' + line if len(line) > 0 else '//' for line in lines]
  return '\n'.join(comments) + '\n'

def get_enum_name(api, enum):
  stripped_name = api['name'].replace('::', '')
  return f'kChrohime{stripped_name}{enum["name"]}'

def get_enum_declaration(api, public_header=False):
  result = 'typedef enum {\n'
  for enum in api['enums']:
    if public_header and 'description' in enum:
      result += prefix_each_line(get_comment(enum), '  ')
    result += f'  {get_enum_name(api, enum)},\n'
  result += f'}} {get_c_type_name(api)};\n\n'
  return result

def get_function_call(apis, api, func, include_this=False):
  call = f'{func["name"]}({params_join(get_c_args(apis, api, func))})'
  if include_this:
    call = f'self->{call}'
  if get_type_of_type(apis, func['returnType']) in [ 'struct', 'geometry', 'enum', 'enum class' ]:
    call = f'FromHime({call})'
  if func['returnType'] == 'const std::u16string&':
    return f'{call}.c_str()'
  return call

def get_method_impl(apis, api, method):
  function_call = get_function_call(apis, api, method, include_this=True)
  if method['returnType'] != 'void':
    return f'return {function_call};'
  else:
    return f'{function_call};'

def get_type_of_type(apis, type_name):
  if type_name.startswith('std::vector<'):
    type_name = type_name[12:-1]
  elif type_name.startswith('absl::optional<'):
    type_name = type_name[15:-1]
  try:
    api = next(api for api in apis if api['name'] == type_name)
    return api['type']
  except StopIteration:
    pass
  return 'primitive'

def get_c_name(data):
  if isinstance(data, dict):
    name = data['name']
  else:
    name = data
  return convert_to_snake_case(name.replace('::', ''))

def get_c_value(value):
  if isinstance(value, str):
    return f'u"{value}"'
  elif isinstance(value, bool):
    return 'true' if value else 'false'
  else:
    return str(value)

def get_c_params(apis, api, method, include_this=False):
  parameters = []
  if include_this:
    parameters.append(f'{get_c_type_name(api)} self')
  for arg in method['args']:
    type_name = get_c_parameter_type(apis, arg['type'])
    parameter_name = get_c_name(arg)
    parameters.append(f'{type_name} {parameter_name}')
    if arg['type'].startswith('std::vector<'):
      parameters.append(f'size_t {parameter_name}_size')
  return parameters

def get_c_args(apis, api, data, include_this=False):
  if include_this:
    data_args = [ {'name': 'self', 'type': api['name']} ] + data['args']
  else:
    data_args = data['args']
  args = []
  for arg in data_args:
    arg_name = get_c_name(arg)
    arg_type = get_type_of_type(apis, arg['type'])
    if arg['type'].startswith('std::vector<'):
      if arg_type == 'struct':
        args.append(f'ToHimeVector<{arg["type"][12:-1]}>({arg_name}, {arg_name}_size)')
      else:
        # For primitives just convert to vector from arary.
        args.append(f'{arg["type"]}({arg_name}, {arg_name} + {arg_name}_size)')
    elif arg_type in [ 'struct', 'geometry', 'enum', 'enum class' ]:
      args.append(f'ToHime({arg_name})')
    elif arg['type'] in [ 'GURL' ]:
      args.append(f'{arg["type"]}({arg_name})')
    else:
      args.append(arg_name)
  return args

def get_c_type_name(data):
  if isinstance(data, dict):
    type_name = data['name']
  else:
    type_name = data
  if type_name in [ 'std::u16string', 'std::u16string_view', 'GURL' ]:
    return 'const char16_t*'
  elif type_name.startswith('Sk'):
    return f'{get_c_name(type_name)}_t'
  elif type_name.startswith('Sk'):
    return f'{get_c_name(type_name)}_t'
  elif type_name[0].isupper():
    return f'hime_{get_c_name(type_name)}_t'
  elif type_name.startswith('gfx::'):
    return f'hime_{get_c_name(type_name[5:])}_t'
  elif type_name.startswith('std::vector<'):
    return get_c_type_name(type_name[12:-1]) + '*'
  elif type_name.startswith('absl::optional<'):
    return get_c_type_name(type_name[15:-1]) + '*'
  else:
    return type_name

def get_c_return_type(apis, type_name):
  if type_name == 'const std::u16string&':
    return 'const char16_t*'
  elif type_name == 'std::u16string':
    return 'void'
  else:
    return get_c_type_name(type_name)

def get_c_parameter_type(apis, type_name):
  result = get_c_type_name(type_name)
  if not type_name.startswith('std::vector<') and get_type_of_type(apis, type_name) == 'struct':
    return result + '*'
  else:
    return result

def get_platform_defines(data):
  defines = []
  if 'platforms' in data:
    platforms = data['platforms']
    if 'win' in platforms:
      defines += [ '_WIN32' ]
    if 'mac' in platforms:
      defines += [ '__APPLE__' ]
    if 'linux' in platforms:
      defines += [ '__linux__' ]
  return defines

def convert_to_snake_case(string):
  snake_case_string = ''
  for index, char in enumerate(string):
    if char.isupper() and index != 0:
      snake_case_string += '_'
    snake_case_string += char.lower()
  return snake_case_string

def prefix_each_line(string, prefix):
  lines = string.splitlines()
  prefixed_lines = [prefix + line for line in lines]
  return '\n'.join(prefixed_lines) + '\n'

def params_join(params):
  return ', '.join(params)

def main():
  parser = argparse.ArgumentParser(
      description='Generate C implementations for the APIs')
  parser.add_argument('--apis-json', required=True,
                      help='JSON file containing APIs')
  parser.add_argument('--output-dir', required=True,
                      help='Directory to save generated C header/impl files')
  parser.add_argument('--public-header', action='store_true', default=False,
                      help='Generate header for publishing')
  args = parser.parse_args()

  with open(args.apis_json, 'r') as json_file:
    data = json.load(json_file)

  if args.public_header:
    with open(os.path.join(args.output_dir, 'chrohime.h'), 'w') as file:
      file.write('#ifndef CHROHIME_H_\n'
                 '#define CHROHIME_H_\n\n')
      # Merge the headers into one file.
      inc_file = os.path.join(__file__, '..', 'chrohime_c_impl.inc')
      with open(os.path.abspath(inc_file), 'r') as inc:
        file.write(inc.read())
      file.write('\n')
      skia_header = os.path.join(__file__, '..', 'skia.h')
      with open(os.path.abspath(skia_header), 'r') as sf:
        file.write(sf.read())
      file.write('\n')
      # Start writing the API declarations.
      write_c_header_file(file, data['apis'], public_header=True)
      file.write('\n#endif  // CHROHIME_H_\n')
  else:
    with open(os.path.join(args.output_dir, 'generated_impls.h'), 'w') as file:
      write_c_header_file(file, data['apis'])

    with open(os.path.join(args.output_dir, 'generated_impls.cc'), 'w') as file:
      write_c_impl_file(file, data['apis'])

if __name__ == '__main__':
  main()
